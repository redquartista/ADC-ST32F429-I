/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2019-02-24

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include "stm32f4xx_conf.h"
#include "stm32f429i_discovery.h"
#include <string.h>
#include <stdio.h>
#include "stm32f429i_discovery_lcd.h"
#include "st_logo1.h"
#include "my.h"
/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */
static void LCD_Config(void);
static void LCD_AF_GPIOConfig(void);
static void delay(__IO uint32_t nCount);

/**
**===========================================================================
**
**  Abstract: main program
**
**  Goal: Read the temperature from LM35 Temperature Sensor and display it on USART and on
**  the in-built LTDC.
**
**	Author: redquartista
**
**	Organization: None
**===========================================================================
*/


int main(void)
{

  /*Declaration of variables, initialization structures*/

   GPIO_InitTypeDef  GPIO_InitStructure, GPIO_InitStructureAN;
   USART_InitTypeDef USART_InitStruct;
   int i = 0;

  /**
  *  IMPORTANT NOTE!d
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  */


  /*Initialize Clock to ADC, LTDC, USART, GPIO*/

  /*ADC1 and LTDC, both the peripherals on ABP2. Hence we initialize the clock to these
   *Peripherals with following functions: */

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_LTDC, ENABLE);

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);

  /*Set PA9 and PA10 to alternate function of USART*/
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);

  /*GPIOA Initialization for PA1, PA9 and PA10*/
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  /*Setting PA1 as Analog pin with no pull*/
  GPIO_InitStructureAN.GPIO_Pin = GPIO_Pin_0;
  GPIO_InitStructureAN.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructureAN.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOA, &GPIO_InitStructureAN);


  /*USART Initialization*/

  USART_InitStruct.USART_BaudRate = 115200;
  USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStruct.USART_Mode = USART_Mode_Tx;
  USART_InitStruct.USART_Parity = USART_Parity_No;
  USART_InitStruct.USART_StopBits = USART_StopBits_1;
  USART_InitStruct.USART_WordLength = USART_WordLength_8b;
  USART_Init(USART1, &USART_InitStruct);
  USART_Cmd	(USART1, ENABLE);

  /*ADC Initialization*/

  ADC_InitTypeDef ADC1_Init_Type;
  ADC1_Init_Type.ADC_Resolution = ADC_Resolution_12b; //Set-up ADC in 12-bit resolution mode
  ADC1_Init_Type.ADC_ScanConvMode = DISABLE; //Set-up ADC for single channel mode
  ADC1_Init_Type.ADC_NbrOfConversion = 1; //Number of "Regular" conversions set at 1
  ADC1_Init_Type.ADC_DataAlign = ADC_DataAlign_Right; //Conversion result will be stored in right-aligned mode
  ADC1_Init_Type.ADC_ContinuousConvMode = ENABLE; //Conversion does not stop at EOC signal
  ADC1_Init_Type.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
  ADC1_Init_Type.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_CommonInitTypeDef ADC1_Common_Init_Type;
  ADC_CommonStructInit(&ADC1_Common_Init_Type);
  /*Initialize ADC1_Common_Init_Type.ADC_Mode to Independent, ADC1_Common_Init_Type.ADC_Prescaler to 2,
   ADC1_Common_Init_Type.ADC_DMAAccessMode to disabled, ADC1_Common_Init_Type.ADC_TwoSamplingDelay to 5  cycles*/



  ADC_CommonInit(&ADC1_Common_Init_Type);
  ADC_Init(ADC1, &ADC1_Init_Type);
  //ADC_ContinuousModeCmd (ADC1, ENABLE);
  ADC_DiscModeCmd (ADC1, DISABLE);
  //ADC_EOCOnEachRegularChannelCmd(ADC1,ENABLE);
  ADC_RegularChannelConfig( ADC1, ADC_Channel_0, 1, ADC_SampleTime_3Cycles);
  ADC_Cmd (ADC1, ENABLE);


  /*ADC Initialization*/


  /*4-March, 12.34AM To-Do (Addressed on March 12 5.33 PM):
  	  1. Check any other configuration is left (Addressed)
  	  2. Check Vref settings (Addressed: No need)
  	  3. Continuous conversion mode to be set again by ADC_ContinuousModeCmd()? (Addressed: No need)
  	  4. What is ADC_SoftwareStartConv(),  ADC_GetSoftwareStartConvStatus() used for? (Addressed)
  	  5. Enable EOC at every conversion? ADC_EOCOnEachRegularChannelCmd()(Addressed: No need)
  	  6. Misc (Addressed)
  */


  /* Initialize LTCD*/
  uint32_t tobuttom = 0;
  uint32_t totop = 0;

  /* Configure LCD : Configure 2 layers w/ Blending and CLUT loading for layer 1 */
  LCD_Config();

  /* Enable Layer 1 */
  LTDC_LayerCmd(LTDC_Layer1, ENABLE);

  /* Reload LTDC configuration  */
 LTDC_ReloadConfig(LTDC_IMReload);
 LTDC_LayerPosition(LTDC_Layer1, 0, (40));
 /* Reload LTDC configuration  */
 LTDC_ReloadConfig(LTDC_IMReload);

  /* Enable The LCD */
  LTDC_Cmd(ENABLE);


  /*LTDC Initialization End*/


  //STM_EVAL_LEDInit(LED3);
  STM_EVAL_LEDInit(LED4);

  //STM_EVAL_LEDOn(LED3);
  STM_EVAL_LEDOn(LED4);

  float tempff, tempDecimals;
  //int count =0;
  /* Infinite loop */
 // LCD_SetColors (0x0000, 0x4db4);
  delay(1000);

  int lineA = 0;
  while (1)
  {

	  STM_EVAL_LEDToggle(LED4);
	  delay(100);

	  for(lineA = 40; lineA <281; lineA++ )
	  {
		  LCD_ClearLine	(lineA);
		  delay(100);
		  LTDC_ReloadConfig(LTDC_IMReload);
		  delay(100);


	  }
	  /* move the picture */



  }


}

static void LCD_Config(void)
{


	  LTDC_InitTypeDef               LTDC_InitStruct;
	  LTDC_Layer_InitTypeDef         LTDC_Layer_InitStruct;
	  GPIO_InitTypeDef               GPIO_InitStructure;

	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	  /* Configure NCS in Output Push-Pull mode */
	  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	  GPIO_Init(GPIOD, &GPIO_InitStructure);


	  /* Configure the LCD Control pins ------------------------------------------*/
	  LCD_CtrlLinesConfig();
	  LCD_ChipSelect(DISABLE);
	  LCD_ChipSelect(ENABLE);

	  /* Configure the LCD_SPI interface -----------------------------------------*/
	  LCD_SPIConfig();

	  /* Power on the LCD --------------------------------------------------------*/
	  LCD_PowerOn();

	  /* Enable the LTDC Clock */
	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_LTDC, ENABLE);

	  /* Enable the DMA2D Clock */
	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2D, ENABLE);

	  /* Configure the LCD Control pins */
	  LCD_AF_GPIOConfig();

	  /* Enable Pixel Clock ------------------------------------------------------*/

	  /* Configure PLLSAI prescalers for LCD */
	  /* PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 Mhz */
	  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAI_N = 192 Mhz */
	  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAI_R = 192/3 = 64 Mhz */
	  /* LTDC clock frequency = PLLLCDCLK / RCC_PLLSAIDivR = 64/8 = 8 Mhz */
	  RCC_PLLSAIConfig(192, 7, 3);
	  RCC_LTDCCLKDivConfig(RCC_PLLSAIDivR_Div8);

	  /* Enable PLLSAI Clock */
	  RCC_PLLSAICmd(ENABLE);
	  /* Wait for PLLSAI activation */
	  while(RCC_GetFlagStatus(RCC_FLAG_PLLSAIRDY) == RESET)
	  {
	  }

	  /* LTDC Initialization -----------------------------------------------------*/

	  /* Initialize the horizontal synchronization polarity as active low*/
	  LTDC_InitStruct.LTDC_HSPolarity = LTDC_HSPolarity_AL;
	  /* Initialize the vertical synchronization polarity as active low */
	  LTDC_InitStruct.LTDC_VSPolarity = LTDC_VSPolarity_AL;
	  /* Initialize the data enable polarity as active low */
	  LTDC_InitStruct.LTDC_DEPolarity = LTDC_DEPolarity_AL;
	  /* Initialize the pixel clock polarity as input pixel clock */
	  LTDC_InitStruct.LTDC_PCPolarity = LTDC_PCPolarity_IPC;

	  /* Timing configuration */
	  /* Configure horizontal synchronization width */
	  LTDC_InitStruct.LTDC_HorizontalSync = 9;
	  /* Configure vertical synchronization height */
	  LTDC_InitStruct.LTDC_VerticalSync = 1;
	  /* Configure accumulated horizontal back porch */
	  LTDC_InitStruct.LTDC_AccumulatedHBP = 29;
	  /* Configure accumulated vertical back porch */
	  LTDC_InitStruct.LTDC_AccumulatedVBP = 3;
	  /* Configure accumulated active width */
	  LTDC_InitStruct.LTDC_AccumulatedActiveW = 269;
	  /* Configure accumulated active height */
	  LTDC_InitStruct.LTDC_AccumulatedActiveH = 323;
	  /* Configure total width */
	  LTDC_InitStruct.LTDC_TotalWidth = 279;
	  /* Configure total height */
	  LTDC_InitStruct.LTDC_TotalHeigh = 327;

	  LTDC_Init(&LTDC_InitStruct);

	  /* Configure R,G,B component values for LCD background color */
	  LTDC_InitStruct.LTDC_BackgroundRedValue = 0;
	  LTDC_InitStruct.LTDC_BackgroundGreenValue = 0;
	  LTDC_InitStruct.LTDC_BackgroundBlueValue = 0;
	  //LCD_SetColors (0x0000, 0x4db4);

	  LTDC_Init(&LTDC_InitStruct);

	  /* LTDC initialization end -------------------------------------------------*/

	  /* Layer1 Configuration ----------------------------------------------------*/

	  /* Windowing configuration */
	  /* In this case all the active display area is used to display a picture then:
	  Horizontal start = horizontal synchronization + Horizontal back porch = 30
	  Horizontal stop = Horizontal start + window width -1 = 30 + 240 -1
	  Vertical start   = vertical synchronization + vertical back porch     = 4
	  Vertical stop   = Vertical start + window height -1  = 4 + 160 -1      */

	  LTDC_Layer_InitStruct.LTDC_HorizontalStart = 30;
	  LTDC_Layer_InitStruct.LTDC_HorizontalStop = (240 + 30 - 1);
	  LTDC_Layer_InitStruct.LTDC_VerticalStart = 4;
	  LTDC_Layer_InitStruct.LTDC_VerticalStop = 240 + 4 -1;

	  /* Pixel Format configuration*/
	  LTDC_Layer_InitStruct.LTDC_PixelFormat = LTDC_Pixelformat_RGB565;

	  /* Alpha constant (255 totally opaque) */
	  LTDC_Layer_InitStruct.LTDC_ConstantAlpha = 255;

	  /* Configure blending factors */
	  LTDC_Layer_InitStruct.LTDC_BlendingFactor_1 = LTDC_BlendingFactor1_PAxCA;
	  LTDC_Layer_InitStruct.LTDC_BlendingFactor_2 = LTDC_BlendingFactor2_PAxCA;

	  /* Default Color configuration (configure A,R,G,B component values) */
	  LTDC_Layer_InitStruct.LTDC_DefaultColorBlue = 0;
	  LTDC_Layer_InitStruct.LTDC_DefaultColorGreen = 0;
	  LTDC_Layer_InitStruct.LTDC_DefaultColorRed = 0;
	  LTDC_Layer_InitStruct.LTDC_DefaultColorAlpha = 0;

	  /* Input Address configuration */
	  //char arrayA[100];
	  //LTDC_Layer_InitStruct.LTDC_CFBStartAdress = (uint32_t)&ST_LOGO_1;
	  LTDC_Layer_InitStruct.LTDC_CFBStartAdress = (uint32_t)&image_data_my;

	  /* the length of one line of pixels in bytes + 3 then :
	  Line Lenth = Active high width x number of bytes per pixel + 3
	  Active high width         = 240
	  number of bytes per pixel = 2    (pixel_format : RGB565)
	  */
	  LTDC_Layer_InitStruct.LTDC_CFBLineLength = ((240 * 2) + 3);

	  /*  the pitch is the increment from the start of one line of pixels to the
	  start of the next line in bytes, then :
	  Pitch = Active high width x number of bytes per pixel
	  */
	  LTDC_Layer_InitStruct.LTDC_CFBPitch = (240 * 2);

	  /* configure the number of lines */
	  LTDC_Layer_InitStruct.LTDC_CFBLineNumber = 240;

	  LTDC_LayerInit(LTDC_Layer1, &LTDC_Layer_InitStruct);

	  /* Layer1 Configuration end ------------------------------------------------*/
	  LTDC_DitherCmd(ENABLE);

	  LCD_Clear(0);
	  delay(100);


}

static void LCD_AF_GPIOConfig(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable GPIOI, GPIOJ, GPIOG, GPIOF, GPIOH AHB Clocks */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | \
    RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOD | \
      RCC_AHB1Periph_GPIOF | RCC_AHB1Periph_GPIOG, ENABLE);

  /* GPIOs Configuration */
  /*
  +------------------------+-----------------------+----------------------------+
  +                       LCD pins assignment                                   +
  +------------------------+-----------------------+----------------------------+
  |  LCD_TFT R2 <-> PC.12  |  LCD_TFT G2 <-> PA.06 |  LCD_TFT B2 <-> PD.06      |
  |  LCD_TFT R3 <-> PB.00  |  LCD_TFT G3 <-> PG.10 |  LCD_TFT B3 <-> PG.11      |
  |  LCD_TFT R4 <-> PA.11  |  LCD_TFT G4 <-> PB.10 |  LCD_TFT B4 <-> PG.12      |
  |  LCD_TFT R5 <-> PA.12  |  LCD_TFT G5 <-> PB.11 |  LCD_TFT B5 <-> PA.03      |
  |  LCD_TFT R6 <-> PB.01  |  LCD_TFT G6 <-> PC.07 |  LCD_TFT B6 <-> PB.08      |
  |  LCD_TFT R7 <-> PG.06  |  LCD_TFT G7 <-> PD.03 |  LCD_TFT B7 <-> PB.09      |
  -------------------------------------------------------------------------------
  |  LCD_TFT HSYNC <-> PC.06  | LCDTFT VSYNC <->  PA.04 |
  |  LCD_TFT CLK   <-> PG.07  | LCD_TFT DE   <->  PF.10 |
  -----------------------------------------------------

  */

  /* GPIOA configuration */
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_LTDC);

  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_6 | \
                             GPIO_Pin_11 | GPIO_Pin_12;
  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* GPIOB configuration */
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource0, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource1, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_LTDC);

  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | \
                             GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;

  GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* GPIOC configuration */
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_LTDC);
  //  GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_LTDC);

  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;// | GPIO_Pin_10;

  GPIO_Init(GPIOC, &GPIO_InitStruct);

  /* GPIOD configuration */
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource3, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_LTDC);

  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_6;

  GPIO_Init(GPIOD, &GPIO_InitStruct);

  /* GPIOF configuration */
  GPIO_PinAFConfig(GPIOF, GPIO_PinSource10, GPIO_AF_LTDC);

  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;

  GPIO_Init(GPIOF, &GPIO_InitStruct);

  /* GPIOG configuration */
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource6, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource7, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource10, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_LTDC);
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, GPIO_AF_LTDC);

  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_10 | \
                             GPIO_Pin_11 | GPIO_Pin_12;

  GPIO_Init(GPIOG, &GPIO_InitStruct);
}


static void delay(__IO uint32_t nCount)
{
  __IO uint32_t index = 0;
  for(index = 100000*nCount; index != 0; index--)
  {
  }
}
/*
 * Callback used by stm324xg_eval_i2c_ee.c.
 * Refer to stm324xg_eval_i2c_ee.h for more info.
 */
uint32_t sEE_TIMEOUT_UserCallback(void)
{
  /* TODO, implement your code here */
  while (1)
  {
  }
}
