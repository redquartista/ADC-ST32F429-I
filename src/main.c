/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2019-02-24

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include "stm32f4xx_conf.h"
#include "stm32f429i_discovery.h"
#include <string.h>
#include <stdio.h>

/* Private macro */
/* Private variables */
/* Private function prototypes */
/* Private functions */

/**
**===========================================================================
**
**  Abstract: main program
**
**  Goal: Read the temperature from LM35 Temperature Sensor and display it on USART and on
**  the in-built LTDC.
**
**	Author: redquartista
**
**	Organization: None
**===========================================================================
*/


int main(void)
{

  /*Declaration of variables, initialization structures*/

   GPIO_InitTypeDef  GPIO_InitStructure, GPIO_InitStructureAN;
   USART_InitTypeDef USART_InitStruct;
   int i = 0;

  /**
  *  IMPORTANT NOTE!d
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  */


  /*Initialize Clock to ADC, LTDC, USART, GPIO*/

  /*ADC1 and LTDC, both the peripherals on ABP2. Hence we initialize the clock to these
   *Peripherals with following functions: */

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_LTDC, ENABLE);

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);

  /*Set PA9 and PA10 to alternate function of USART*/
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);

  /*GPIOA Initialization for PA1, PA9 and PA10*/
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  /*Setting PA1 as Analog pin with no pull*/
  GPIO_InitStructureAN.GPIO_Pin = GPIO_Pin_0;
  GPIO_InitStructureAN.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructureAN.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOA, &GPIO_InitStructureAN);


  /*USART Initialization*/

  USART_InitStruct.USART_BaudRate = 115200;
  USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStruct.USART_Mode = USART_Mode_Tx;
  USART_InitStruct.USART_Parity = USART_Parity_No;
  USART_InitStruct.USART_StopBits = USART_StopBits_1;
  USART_InitStruct.USART_WordLength = USART_WordLength_8b;
  USART_Init(USART1, &USART_InitStruct);
  USART_Cmd	(USART1, ENABLE);

  /*ADC Initialization*/

  ADC_InitTypeDef ADC1_Init_Type;
  ADC1_Init_Type.ADC_Resolution = ADC_Resolution_12b; //Set-up ADC in 12-bit resolution mode
  ADC1_Init_Type.ADC_ScanConvMode = DISABLE; //Set-up ADC for single channel mode
  ADC1_Init_Type.ADC_NbrOfConversion = 1; //Number of "Regular" conversions set at 1
  ADC1_Init_Type.ADC_DataAlign = ADC_DataAlign_Right; //Conversion result will be stored in right-aligned mode
  ADC1_Init_Type.ADC_ContinuousConvMode = ENABLE; //Conversion does not stop at EOC signal
  ADC1_Init_Type.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
  ADC1_Init_Type.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_CommonInitTypeDef ADC1_Common_Init_Type;
  ADC_CommonStructInit(&ADC1_Common_Init_Type);
  /*Initialize ADC1_Common_Init_Type.ADC_Mode to Independent, ADC1_Common_Init_Type.ADC_Prescaler to 2,
   ADC1_Common_Init_Type.ADC_DMAAccessMode to disabled, ADC1_Common_Init_Type.ADC_TwoSamplingDelay to 5  cycles*/



  ADC_CommonInit(&ADC1_Common_Init_Type);
  ADC_Init(ADC1, &ADC1_Init_Type);
  //ADC_ContinuousModeCmd (ADC1, ENABLE);
  ADC_DiscModeCmd (ADC1, DISABLE);
  //ADC_EOCOnEachRegularChannelCmd(ADC1,ENABLE);
  ADC_RegularChannelConfig( ADC1, ADC_Channel_0, 1, ADC_SampleTime_15Cycles);
  ADC_Cmd (ADC1, ENABLE);


  /*ADC Initialization*/


  /*4-March, 12.34AM To-Do (Addressed on March 12 5.33 PM):
  	  1. Check any other configuration is left (Addressed)
  	  2. Check Vref settings (Addressed: No need)
  	  3. Continuous conversion mode to be set again by ADC_ContinuousModeCmd()? (Addressed: No need)
  	  4. What is ADC_SoftwareStartConv(),  ADC_GetSoftwareStartConvStatus() used for? (Addressed)
  	  5. Enable EOC at every conversion? ADC_EOCOnEachRegularChannelCmd()(Addressed: No need)
  	  6. Misc (Addressed)
  */


  /* Initialize LTCD*/


  //STM_EVAL_LEDInit(LED3);
  STM_EVAL_LEDInit(LED4);

  //STM_EVAL_LEDOn(LED3);
  STM_EVAL_LEDOn(LED4);

  float tempff, tempDecimals;
  //int count =0;
  /* Infinite loop */

  while (1)
  {
	  ADC_SoftwareStartConv(ADC1); //Starts Conversion
//	  if(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC))
//	  {
		  //ADC_ClearFlag (ADC1, ADC_FLAG_EOC);
//		  tempff = (float)ADC_GetConversionValue(ADC1);
//		  tempff=(300*tempff/4096);
//		  tempff=tempff+2;
//		  tempDecimals = (tempff-(int)tempff)*100;
		  //printf("Temp = %d.%d C \r\n", (int)tempff, (int)tempDecimals);
	  printf("%d \r\n", (int)ADC_GetConversionValue(ADC1));
	  STM_EVAL_LEDToggle(LED4);
	  for(i=0;i<1000000;i++);
//	  }


  }
}

/*
 * Callback used by stm324xg_eval_i2c_ee.c.
 * Refer to stm324xg_eval_i2c_ee.h for more info.
 */
uint32_t sEE_TIMEOUT_UserCallback(void)
{
  /* TODO, implement your code here */
  while (1)
  {
  }
}
